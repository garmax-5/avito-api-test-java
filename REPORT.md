# Отчёт о тестировании

## Общая информация

1. В связи с отсутствием технической документации и формального описания бизнес-логики сервиса, тест-кейсы на валидацию бизнес-ограничений параметров запросов (диапазоны значений, взаимосвязи полей, бизнес-правила) не разрабатывались.
2. В рамках тестирования была выполнена проверка корректности обработки обязательных полей, типов данных, структуры запросов и ответов, а также обработки невалидных входных данных.

В данном файле собраны проверки, которые основывались на предположениях и анализе `swagger.yml`, `application_collection` и API-ответов.

## Обнаруженные баги/проблемы

1. В `postman_collection` обнаружена несогласованность в названиях полей в теле запроса и ответа (`sellerId` и `sellerID`): для некоторых запросов используется название `sellerID`, для других — `sellerId`.
2. Если в POST-запросе `POST /api/1/item` поле `sellerId` передать как тип, то возвращается тело ответа вида:

   ```json
   {
     "result": {
     "message": "",
     "messages": {}
     },
     "status": "не передано тело объявления"
   }
   ```

3. Если в POST-запросе `POST /api/1/item` для поля `likes` задать значение `0`, то возвращается тело ответа вида:

   ```json
   {
     "result": {
     "message": "поле likes обязательно",
     "messages": {}
     },
     "status": "400"
   }
   ```

   Аналогично для полей `viewCount` и `contacts`.

4. Если в POST-запросе `POST /api/1/item` поле `likes` передать как тип, то возвращается тело ответа вида:

   ```json
   {
     "result": {
     "message": "",
     "messages": {}
     },
     "status": "не передано тело объявления"
   }
   ```

   Аналогично для полей `viewCount` и `contacts`.

5. Если в POST-запросе `POST /api/1/item` для поля `likes` задать отрицательное значение, то запрос выполнится и объявление сохранится. Аналогично для полей `viewCount` и `contacts`.
6. Если в POST-запросе `POST /api/1/item` для поля `price` задать отрицательное значение, то запрос выполнится и объявление сохранится. Однако при значении `0` возвращается тело ответа:

   ```json
   {
     "result": {
     "message": "поле price обязательно",
     "messages": {}
     },
     "status": "400"
   }
   ```

7. Если в POST-запросе `POST /api/1/item` поле `price` передать как тип, то возвращается тело ответа вида:

   ```json
   {
     "result": {
     "message": "",
     "messages": {}
     },
     "status": "не передано тело объявления"
   }
   ```

8. Если в POST-запросе `POST /api/1/item` в поле `name` передать пустую строку (`""`), то возвращается тело ответа:

   ```json
   {
     "result": {
     "message": "поле name обязательно",
     "messages": {}
     },
     "status": "400"
   }
   ```

9. Если в POST-запросе `POST /api/1/item` отправить невалидный JSON, то возвращается тело ответа:

   ```json
   {
     "result": {
     "message": "",
     "messages": {}
     },
     "status": "не передан объект - объявление"
   }
   ```

10. Если в GET-запросе `GET /api/1/{sellerID}/item` передать `sellerID` несуществующего продавца, то сервер вернёт HTTP Status: `200 OK` и пустой список. Предполагаю, что должен возвращаться HTTP Status: `404 Not Found` и тело ответа с информацией о том, что продавца с таким идентификатором не существует.
11. Если в GET-запросе `GET /api/2/statistic/{id}` передать невалидный `id`, то сервер вернёт HTTP Status: `404 Not Found`. Лучше возвращать HTTP Status: `400 Bad Request`.
12. Во время выполнения теста была обнаружена блокирующая проблема: POST-запрос `POST /api/1/item` не возвращает созданный объект с сгенерированным идентификатором. Из-за этой проблемы тесты, зависящие от возвращаемого идентификатора, не могут быть успешно выполнены.
